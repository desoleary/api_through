{
  "name": "http-mitm-proxy",
  "version": "0.0.1",
  "description": "HTTP Man In The Middle (MITM) Proxy",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": "",
  "keywords": [
    "mitm",
    "proxy"
  ],
  "author": {
    "name": "Joe Ferner",
    "email": "joe@fernsroth.com"
  },
  "license": "MIT",
  "dependencies": {
    "optimist": "~0.3.5",
    "async": "~0.1.22",
    "mkdirps": "0.0.0"
  },
  "readme": "# HTTP MITM Proxy\n\nHTTP Man In The Middle (MITM) Proxy written in node.js. Supports capturing and modifying the request and response data.\n\n# Example\n\nThis example will modify any search results coming from google and replace all the result titles with \"Pwned!\".\n\n```javascript\nvar Proxy = require('http-mitm-proxy');\nvar proxy = Proxy();\n\nproxy.onError(function(ctx, err) {\n  console.error('proxy error:', err);\n});\n\nproxy.onRequest(function(ctx, callback) {\n  if (ctx.clientToProxyRequest.headers.host == 'www.google.com'\n    && ctx.clientToProxyRequest.url.indexOf('/search') == 0) {\n    ctx.use(Proxy.gunzip);\n\n    ctx.onResponseData(function(ctx, chunk, callback) {\n      chunk = new Buffer(chunk.toString().replace(/<h3.*?<\\/h3>/g, '<h3>Pwned!</h3>'));\n      return callback(null, chunk);\n    });\n  }\n  return callback();\n});\n\nproxy.listen({port: 8081});\n```\n\n# SSL\n\nCreate a CA\n```\ncd ~/.http-mitm-proxy\nopenssl genrsa -out ca/ca.key 1024\nopenssl req -new -x509 -days 3650 -extensions v3_ca -keyout ca/cakey.pem -out ca/cacert.pem -config /etc/ssl/openssl.cnf\necho \"02\" > ca/cacert.srl\n\nopenssl genrsa -out www.google.com-key.pem 1024\nopenssl req -new -key www.google.com-key.pem -out www.google.com.csr\nopenssl x509 -req -days 3650 -CA ca/cacert.pem -CAkey ca/cakey.pem -in www.google.com.csr -out www.google.com-cert.pem\n```\n\nImport ca/cacert.pem into the browser.\n\n# API\n\n## Proxy\n * [listen](#proxy_listen)\n * [onError](#proxy_onError)\n * [onCertificateRequired](#proxy_onCertificateRequired)\n * [onCertificateMissing](#proxy_onCertificateMissing)\n * [onRequest](#proxy_onRequest)\n * [onRequestData](#proxy_onRequestData)\n * [onResponse](#proxy_onResponse)\n * [onResponseData](#proxy_onResponseData)\n * [use](#proxy_use)\n\n## Context\n\n Context functions only effect the current request/response. For example you may only want to gunzip requests\n made to a particular host.\n\n * [onError](#proxy_onError)\n * [onRequest](#proxy_onRequest)\n * [onRequestData](#proxy_onRequestData)\n * [addRequestFilter](#context_addRequestFilter)\n * [onResponse](#proxy_onResponse)\n * [onResponseData](#proxy_onResponseData)\n * [addResponseFilter](#context_addResponseFilter)\n * [use](#proxy_use)\n\n<a name=\"proxy\"/>\n## Proxy\n\n<a name=\"proxy_listen\" />\n### proxy.listen\n\nStarts the proxy listening on the given port.\n\n__Arguments__\n\n * options - An object with the following options:\n  * port - The port to listen on (default: 8080).\n  * sslCertCacheDir - Path to the certificates cache directory (default: ~/.http-mitm-proxy)\n\n__Example__\n\n    proxy.listen({ port: 80 });\n\n<a name=\"proxy_onError\" />\n### proxy.onError(fn) or ctx.onError(fn)\n\nAdds a function to the list of functions to get called if an error occures.\n\n__Arguments__\n\n * fn(ctx, err) - The function to be called on an error.\n\n__Example__\n\n    proxy.onError(function(ctx, err) {\n      console.error('error in proxy for url:', ctx.clientToProxyRequest.url, err);\n    });\n\n<a name=\"proxy_onCertificateRequired\" />\n### proxy.onCertificateRequired = function(hostname, callback)\n\nAllows the default certificate name/path computation to be overwritten.\n\nThe default behavior expects `{hostname}-key.pem` and `{hostname}-cert.pem` files to be at `self.sslCertCacheDir`.\n\n__Arguments__\n\n * hostname - Requested hostname.\n * callback - The function to be called when certificate files' path were already computed.\n\n__Example__\n\n    proxy.onCertificateRequired = function(hostname, callback) {\n      return callback(null, {\n        keyFile: path.resolve('/ca/certs/', hostname + '.key'),\n        certFile: path.resolve('/ca/certs/', hostname + '.crt')\n        });\n    };\n\n<a name=\"proxy_onCertificateMissing\" />\n### proxy.onCertificateMissing = function(ctx, files, callback)\n\nAllows you to handle missing certificate files for current request, for example, creating them on the fly.\n\n__Arguments__\n\n* ctx - Context with the following properties\n * hostname - The hostname which requires certificates\n * data.keyFileExists - Whether key file exists or not\n * data.certFileExists - Whether certificate file exists or not\n* files - missing files names (`files.keyFile` and `files.certFile`)\n* callback - The function to be called to pass certificate data back (`keyFileData` and `certFileData`)\n\n__Example__\n\n    proxy.onCertificateMissing = function(ctx, files, callback) {\n      console.log('Looking for \"%s\" certificates',   ctx.hostname);\n      console.log('\"%s\" missing', ctx.files.keyFile);\n      console.log('\"%s\" missing', ctx.files.certFile);\n\n      // Here you have the last chance to provide certificate files data\n      // A tipical use case would be creating them on the fly\n      //\n      // return callback(null, {\n      //   key: keyFileData,\n      //   cert: certFileData\n      // });\n      };\n\n<a name=\"proxy_onRequest\" />\n### proxy.onRequest(fn) or ctx.onRequest(fn)\n\nAdds a function to get called at the beginning of a request.\n\n__Arguments__\n\n * fn(ctx, callback) - The function that gets called on each request.\n\n__Example__\n\n    proxy.onRequest(function(ctx, callback) {\n      console.log('REQUEST:', ctx.clientToProxyRequest.url);\n      return callback();\n    });\n\n<a name=\"proxy_onRequestData\" />\n### proxy.onRequestData(fn) or ctx.onRequestData(fn)\n\nAdds a function to get called for each request data chunk (the body).\n\n__Arguments__\n\n * fn(ctx, chunk, callback) - The function that gets called for each data chunk.\n\n__Example__\n\n    proxy.onRequestData(function(ctx, chunk, callback) {\n      console.log('REQUEST DATA:', chunk.toString());\n      return callback(null, chunk);\n    });\n\n<a name=\"proxy_onResponse\" />\n### proxy.onResponse(fn) or ctx.onResponse(fn)\n\nAdds a function to get called at the beginning of the response.\n\n__Arguments__\n\n * fn(ctx, callback) - The function that gets called on each response.\n\n__Example__\n\n    proxy.onResponse(function(ctx, callback) {\n      console.log('BEGIN RESPONSE');\n      return callback();\n    });\n\n<a name=\"proxy_onResponseData\" />\n### proxy.onResponseData(fn) or ctx.onResponseData(fn)\n\nAdds a function to get called for each response data chunk (the body).\n\n__Arguments__\n\n * fn(ctx, chunk, callback) - The function that gets called for each data chunk.\n\n__Example__\n\n    proxy.onResponseData(function(ctx, chunk, callback) {\n      console.log('RESPONSE DATA:', chunk.toString());\n      return callback(null, chunk);\n    });\n\n<a name=\"proxy_use\" />\n### proxy.use(module) or ctx.use(module)\n\nAdds a module into the proxy. Modules encapsulate multiple life cycle processing functions into one object.\n\n__Arguments__\n\n * module - The module to add. Modules contain a hash of functions to add.\n\n__Example__\n\n    proxy.use({\n      onError: function(ctx, err) { },\n      onRequest: function(ctx, callback) { return callback(); },\n      onRequestData: function(ctx, chunk, callback) { return callback(null, chunk); },\n      onResponse: function(ctx, callback) { return callback(); },\n      onResponseData: function(ctx, chunk, callback) { return callback(null, chunk); }\n    });\n\n<a name=\"context\"/>\n## Context\n\n<a name=\"context_addRequestFilter\" />\n### ctx.addRequestFilter(stream)\n\nAdds a stream into the request body stream.\n\n__Arguments__\n\n * stream - The read/write stream to add in the request body stream.\n\n__Example__\n\n    ctx.addRequestFilter(zlib.createGunzip());\n\n<a name=\"context_addRequestFilter\" />\n### ctx.addResponseFilter(stream)\n\nAdds a stream into the response body stream.\n\n__Arguments__\n\n * stream - The read/write stream to add in the response body stream.\n\n__Example__\n\n    ctx.addResponseFilter(zlib.createGunzip());\n",
  "readmeFilename": "README.md",
  "_id": "http-mitm-proxy@0.0.1",
  "_shasum": "1c9b294fa3d569417cfe490f5c6cbba9399a8572",
  "_resolved": "git+https://github.com/joeferner/node-http-mitm-proxy#a358bf2ee74a47f8936c9b3221c6d1c675c14fd9",
  "_from": "http-mitm-proxy@git+https://github.com/joeferner/node-http-mitm-proxy#master"
}
